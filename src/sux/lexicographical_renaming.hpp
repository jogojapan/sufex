/*
 * lexicographical_renaming.hpp
 *
 *  Created on: 2013/01/01
 *      Author: jogojapan
 */

#ifndef LEXICOGRAPHICAL_RENAMING_HPP_
#define LEXICOGRAPHICAL_RENAMING_HPP_

#include <utility>
#include "../util/more_type_traits.hpp"
#include "../util/more_algorithm.hpp"

namespace rlxalgo {

  template <typename T> using deref     = rlxtype::deref<T>;
  template <typename T> using elem_type = rlxtype::elemtype<T>;

  struct lexicographical_renaming
  {
    enum class recursion : bool { unneeded , needed };

    template <typename Fun>
    struct is_posmap
    {
      typedef rlxtype::function_traits<Fun> traits;
      static constexpr bool value =
          ((traits::arity == 1)
              && (std::is_integral<typename traits::template arg<0>::type>::value)
              && (std::is_integral<typename traits::result_type>::value));
    };

    template <typename Pos>
    static Pos std_posmap(Pos pos)
    { return pos; }

    /**
     * Create new lexicographical names in another container.
     * @return A flag that indicates whether a distinct lexicographical
     *    name was given to each unique trigram (recusion::unneeded), or
     *    not (recusion::needed).
     */
    template <typename It, typename DestIt,
              typename Posmap = decltype(std_posmap<typename deref<It>::pos_type>)>
    static recursion apply(
        It                           start,
        It                           end,
        rlxutil::parallel::portions &portions,
        DestIt                       dest_start,
        DestIt                       dest_end,
        bool                         (&eq)      (const deref<It> &, const deref<It> &),
        Posmap                      &&posmap = std_posmap<typename deref<It>::pos_type>,
        typename std::enable_if<is_posmap<Posmap>::value,int>::type = 0)
    {
      using std::move;
      using std::size_t;
      using std::future;
      using std::make_pair;
      using std::make_tuple;
      using std::accumulate;
      using std::distance;

      using rlxtype::is_compatible;
      using rlxutil::parallel::tools::wait_for;
      using rlxutil::parallel::tools::arg_generator;

      typedef deref<It>                     elem_type;
      typedef typename elem_type::pos_type  pos_type;
      typedef deref<DestIt>                 dest_type;
      typedef rlxutil::parallel::portions::adjustment adjustment;

      /* Verify that the destination vector has the right element
       * type. */
      static_assert(is_compatible<dest_type,pos_type>::value,
          "Attempt to perform lexicographical renaming where the "
          "elements of the destination vector do not have the right "
          "data type to store position information from the source "
          "vector");

      if (distance(start,end) != distance(dest_start,dest_end))
        throw std::out_of_range("Attempt to perform lexicographical "
            "renaming into a destination vector that does not have "
            "the right size.");

      /* Ensure that threads generated by the parallel vector
       * implementation start and end at boundaries that do
       * not cause incorrect lexical renaming (the trigram
       * at the beginning of a thread must not be identical
       * to the trigram at the end of the previous thread.) */
      portions.assign(
          start,end,portions.num(),
          [&eq](It /*beg*/,It it,It end)
          {
            if (it != end) {
                It nx = next(it);
                if ((nx != end) && eq(*it,*nx))
                  return adjustment::needed;
            }
            return adjustment::unneeded;
          });

      /* Fill the new vector with the new lexical names. Each thread
       * will start from 0 as the first new name. The future returned
       * by each thread provides the total number of unique names
       * created by that thread. */
      auto dest_futs =
          portions.apply(start,end,
              [&eq,&posmap](It from, It to, It beg, DestIt dest_beg)
              {
                pos_type current_name
                { 0 };

                if (from == to)
                  return current_name;

                *(dest_beg + posmap(distance(beg,from))) = current_name;
                It next = std::next(from);
                while (next != to)
                  {
                    if (!eq(*from,*next))
                      ++current_name;
                    *(dest_beg + posmap(distance(beg,next))) = current_name;
                    from = next;
                    ++next;
                  }

                /* Return the current name, i.e. the total
                 * number of unique names. */
                ++current_name;
                return current_name;
              },
              start,dest_start
          );

      /* Wait for the threads to finish and add up all the totals. */
      std::vector<pos_type> total_vec(dest_futs.size());
      std::transform(dest_futs.begin(),dest_futs.end(),total_vec.begin(),
          [](future<pos_type> &fut){ return fut.get(); }
      );
      pos_type total_names
      { rlxutil::algorithm::make_cumulative(total_vec.begin(),total_vec.end()) };

      /* From the second thread on, all threads require post-correction
       * since the names they created start at 0 but need to start at
       * wherever the previous thread ended. */
      auto correction_futs =
          portions.apply_dynargs(start,end,
              [&posmap](It from, It to, It beg, DestIt dest_beg, bool skip, size_t initial)
              {
                if (!skip)
                  while (from != to) {
                      *(dest_beg + posmap(distance(beg,from))) += initial;
                      ++from;
                  }
              },
              arg_generator([start,dest_start,&total_vec](size_t thread)
              {
                if (thread == 0)
                  return make_tuple(start,dest_start,true,(pos_type)0);
                return make_tuple(start,dest_start,false,total_vec[thread-1]);
              })
          );

      /* Wait for threads to finish. */
      wait_for(correction_futs);

      /* Return a pair { bool , vec } where bool is true if all new
       * lexicographical names were unique, and vec is the vector with
       * the new names. */
      pos_type original_size = distance(start,end);
      return (total_names == original_size) ? recursion::unneeded : recursion::needed;
    }

    /**
     * Given the container type for the input trigrams
     * (e.g. std::vector<TrigramImpl<...>>), determines
     * the type we expect the elements of the destination
     * container for lexicographical renaming to have.
     */
    template <typename InputVector>
    struct std_dest_element
    {
      typedef rlxtype::deref<decltype(std::declval<InputVector>().begin())> elem_type;
      typedef typename elem_type::pos_type type;
    };

    template <typename InpVector>
    using result_type =
        std::pair<recursion,std::vector<typename std_dest_element<InpVector>::type>>;

    /**
     * The `apply()` function returns a result that includes information
     * about whether further recusion is required, as well as the actual
     * vector of lexicographical names. Use the function below to
     * extract information about whether recusion is needed:
     *
     *     is<recusion::needed>(result)
     */
    template <recursion val, typename OutVector>
    static bool is(const std::pair<recursion,OutVector> &result)
    { return (result.first == val); }

    /**
     * Extract the new (lexicographically renamed) string (i.e.,
     * chracter vector) from the results of lexicographical
     * renaming. This moves the string out of the result; so
     * it can be done only once for any result object. (Later
     * attempts to do it again will return an empty vector.)
     *
     *     auto result = lexicographical_renaming<...>.apply();
     *     parallel_vector<...> vec = move_newstring_from(result);
     */
    template <typename OutVector>
    static typename std::remove_reference<OutVector>::type &&
    move_newstring_from(std::pair<recursion,OutVector> &result)
    { return std::move(result.second); }

    /**
     * Access to the new (lexicographically renamed) string.
     */
    template <typename OutVector>
    static const OutVector &newstring_of(
        const std::pair<recursion,OutVector> &result)
    { return result.second; }

    /**
     * Access to the new (lexicographically renamed) string.
     */
    template <typename OutVector>
    static OutVector &newstring_of(std::pair<recursion,OutVector> &result)
    { return result.second; }

    /**
     * Perform lexicographical renaming on a lexicographically sorted vector
     * of trigrams. This produces a string (represented as parallel_vector
     * of characters) that contains one character (i.e. one integer) for
     * every trigram of the input vector. The integers will start with 0 and
     * increment for every unique trigram where it occurs for the first time.
     *
     * Usage:
     *
     *     unsigned threads
     *     { 4 };
     *     // ...
     *     std::vector<TrigramImpl<...>> trigrams;
     *     rlxutil::parallel::portions portions
     *     { trigrams.begin(), trigrams.end(), threads };
     *     // ...
     *     typedef lexicographical_renaming lex;
     *
     *     auto result    = lex::apply(trigrams,portions);
     *     auto newstring = lex::move_newstring_from(result);
     *     if (lex::is<recursion::needed>(result))
     *       // perform recursion...
     *
     */
    template <typename InpVector,
              typename Posmap = decltype(std_posmap<typename elem_type<InpVector>::pos_type>)>
    static result_type<InpVector> apply(
        InpVector                   &trigrams,
        rlxutil::parallel::portions &portions,
        bool                        (&eq)(const elem_type<InpVector>&, const elem_type<InpVector> &),
        Posmap                      &&posmap = std_posmap<typename elem_type<InpVector>::pos_type>,
        typename std::enable_if<is_posmap<Posmap>::value,int>::type = 0)
    {
      using std::forward;
      typedef typename std_dest_element<InpVector>::type pos_type;
      std::vector<pos_type> dest_vec(trigrams.size());
      lexicographical_renaming::recursion flag = apply(
          trigrams.begin(),trigrams.end(),portions,dest_vec.begin(),dest_vec.end(),
          eq,forward<Posmap>(posmap));
      return { flag , std::move(dest_vec) };
    }

  };

  template
    <typename InpVector,
     typename Posmap = decltype(lexicographical_renaming::std_posmap
         <typename elem_type<InpVector>::pos_type>)>
  lexicographical_renaming::result_type<InpVector> rename_lexicographically(
      InpVector                   &trigrams,
      rlxutil::parallel::portions &portions,
      bool                        (&eq)(const elem_type<InpVector> &, const elem_type<InpVector> &),
      Posmap                      &&posmap = lexicographical_renaming::std_posmap<typename elem_type<InpVector>::pos_type>,
      typename std::enable_if<lexicographical_renaming::is_posmap<Posmap>::value,int>::type = 0)
  {
    using std::forward;
    return lexicographical_renaming::apply(trigrams,portions,eq,forward<Posmap>(posmap));
  }

  template <typename InpVector,
            typename Posmap = decltype(lexicographical_renaming::std_posmap
                <typename elem_type<InpVector>::pos_type>)>
  lexicographical_renaming::result_type<InpVector> rename_lexicographically(
      InpVector   &trigrams,
      bool        (&eq)(const elem_type<InpVector> &, const elem_type<InpVector> &),
      unsigned    threads  = 4,
      Posmap      &&posmap = lexicographical_renaming::std_posmap<typename elem_type<InpVector>::pos_type>,
      typename std::enable_if<lexicographical_renaming::is_posmap<Posmap>::value,int>::type = 0)
  {
    using std::forward;

    rlxutil::parallel::portions portions
    { trigrams.begin(), trigrams.end(), threads };

    return lexicographical_renaming::apply(trigrams,portions,eq,forward<Posmap>(posmap));
  }

}


#endif /* LEXICOGRAPHICAL_RENAMING_HPP_ */
